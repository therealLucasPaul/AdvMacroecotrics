---
title: "4423 Advanced Macroeconometrics 1 - Assignment 1"
author: "Unterweger L., Pirich G., Tijani S."
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

# Setup

Importing necessary packages

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(vars)
library(ggplot2)
library(stats)
library(urca)
library(forecast)
library(tidyverse)
library(quantmod)
library(lubridate)
library(gridExtra)
library(stargazer)
```

# Excercise 1: FRED-MD

\textit{Download the current version of the FRED-MD database and load it into R (or another statistical software of your choice). Note that the second line in the CSV-file denotes the suggested transformation, you have to remove it.}

```{r}
fredmd <- read.csv("FRED_MD_data.csv")[-1,]
head(fredmd[,1:6])
```

\textit{Create a function that takes a vector containing observations of a time series as input and returns a dataframe with the following transformed series in its columns as output:
\begin{itemize}
\item the original time series in its raw form.
\item the log-transformed time series.
\item month-on-month growth rates in percent.
\item year-on-year growth rates in percent.
\item the first lag of the year-on-year growth rates of the time series.
\end{itemize}}

```{r}
ts_transform <- function(x) {
  output <- data.frame(matrix(NA,    # Create empty data frame
                                 nrow = NROW(x),
                                 ncol = 0))
  output$raw <- x
  output$log <- log(x)
  output$mom <- ((x-lag(x))/lag(x))*100
  output$yoy <- ((x-lag(x, 12))/lag(x, 12))*100
  output$yoy_1stlag <- lag((x-lag(x, 12))/lag(x, 12))*100
  return(output)
}
```

\textit{Use the created function to create a dataframe with the various transformation for US industrial production (mnemonic INDPRO), plot the logged time series and the yearly changes produced by the function. Briefly describe the properties of the time series.}

```{r}
industrial_prod <- cbind(date=as.Date(fredmd$sasdate, "%m/%d/%Y"), ts_transform(fredmd$INDPRO))
head(industrial_prod)
p1 <- ggplot(na.omit(industrial_prod), aes(x=date,y=log))+
  geom_line( color="#69b3a2", alpha=0.9, linetype=1) +
  ylab("Logged Industrial Production (INDPRO)")

p2 <- ggplot(na.omit(industrial_prod), aes(x=date,y=yoy))+
  geom_line( color="#69b3a2", alpha=0.9, linetype=1) +
  ylab("YoY Change of Industrial Production (INDPRO)")

grid.arrange(p1, p2, ncol=2, nrow = 1)
```

<!--ADD INTERPRETATION -->

\textit{Using suitable functions from the stats and urca package, assess the properties of both logged industrial production and its yearly growth rate. Plot the autocorrelation function and perform Dickey-Fuller tests to test for a unit root (note the different specifications, i.e. including a drift or a trend), interpret the results.}
```{r}
log_INDPRO <- ts(industrial_prod$log, frequency = 12, start = c(1959,1,1))
yoy_INDPRO <- ts(industrial_prod$yoy, frequency = 12, start = c(1959,1,1))

par(mfrow=c(1,2))
Acf(log_INDPRO)
Acf(yoy_INDPRO)
```


```{r}
summary(ur.df(na.omit(industrial_prod$yoy), lags = 0, type="none")) # Process is stationary
summary(ur.df(na.omit(industrial_prod$log), lags = 0, type="none")) # Cannot reject H0
summary(ur.df(na.omit(industrial_prod$log), lags = 0, type="drift"))
summary(ur.df(na.omit(industrial_prod$log), lags = 0, type="trend"))
```

<!-- INTERPRETATION -->

\textit{Estimate a suitable AR model (e.g. using the ar.ols() function) for the stationary time series (as determined in the previous point). How is the lag order determined by default? Use the estimated model to produceforecasts for the next year and plot them. Interpret their behaviour (i.e. are they converging towards a certain value? What could that be?). Use the produced forecasts to also forecast the change in the original time series.}

```{r}
mod_log <- ar.ols(industrial_prod$log, na.action = na.omit, 
                demean = TRUE, intercept = TRUE)
summary(mod_log)

mod_yoy <- ar.ols(industrial_prod$yoy, na.action = na.omit,
                demean = FALSE, intercept = FALSE)
summary(mod_yoy)
```
By default the lag order is determined by the AIC information criterion. For the log of INDPRO a lag order of 25 is estimated. The model for the year on year changes is estimated with lag order 26.

```{r}
predict_mod_log <- predict(mod_log, na.omit(industrial_prod$log), n.ahead = 12)

ts_log <- ts(industrial_prod$log, start=c(1959, 1), end=c(2023,1), frequency=12)
ts_log_pred <- ts(c(tail(ts_log,n=1), predict_mod_log$pred), start = c(2023, 1), end=c(2024,2), frequency=12)

plot.ts(ts_log,
        xlim = c(2014, 2024),
        ylim = c(4.4,4.7),
        xlab = "Time",
        ylab = "log(INDPRO)",
        main = "12-step ahead forecast for log(INDPRO)", 
        col = "steelblue") #plotting th predicted values) #plotting th predicted values
points(ts_log_pred, type = "l",lty=2, col = "darkred")
```


```{r}
predict_mod_log <- predict(mod_log, na.omit(industrial_prod$log), n.ahead = 480)

ts_log <- ts(industrial_prod$log, start=c(1959, 1), end=c(2023,1), frequency=12)
ts_log_pred <- ts(predict_mod_log$pred, start = c(2023, 1), end=c(2062,1), frequency=12)

plot.ts(ts_log,
        xlim = c(2000, 2062),
        ylim = c(4.3,4.8),
        xlab = "Time",
        ylab = "log(INDPRO)",
        main = "40-year forecast for log(INDPRO)", 
        col = "steelblue") #plotting the predicted values
points(ts_log_pred, type = "l", col = "darkred")
```

<!-- INTERPRETATION OF CONVERGENCE -->

```{r}
predict_mod_yoy <- predict(mod_yoy, na.omit(industrial_prod$yoy), n.ahead = 12)

ts_yoy <- ts(industrial_prod$yoy, start=c(1959, 1), end=c(2023,1), frequency=12)
ts_yoy_pred <- ts(c(tail(na.omit(industrial_prod$yoy),n=1),predict_mod_yoy$pred), start = c(2023, 1), end=c(2024,2), frequency=12)

plot.ts(ts_yoy,
        xlim = c(2000, 2024),
        xlab = "Time",
        ylab = "yoy(INDPRO)",
        main = "12-step ahead forecast for yoy(INDPRO)", 
        col = "steelblue") #plotting the predicted values
points(ts_yoy_pred, type = "l", col = "darkred")
```

```{r}
predict_mod_yoy <- predict(mod_yoy, na.omit(industrial_prod$yoy), n.ahead = 480)

ts_yoy <- ts(industrial_prod$yoy, start=c(1959, 1), end=c(2023,1), frequency=12)
ts_yoy_pred <- ts(c(tail(na.omit(industrial_prod$yoy),n=1),predict_mod_yoy$pred), start = c(2023, 1), end=c(2062,1), frequency=12)

plot.ts(ts_yoy,
        xlim = c(2000, 2062),
        xlab = "Time",
        ylab = "yoy(INDPRO)",
        main = "Forecast for yoy(INDPRO)", 
        col = "steelblue") #plotting th predicted values
points(ts_yoy_pred, type = "l", col = "darkred")
```
<!-- INTERPRETATION OF CONVERGENCE -->

```{r}
last_origvalues <- tail(na.omit(industrial_prod$raw),12)
pred_yoygrowth <- predict_mod_yoy$pred
orig_forecast <- vector()
for(i in 1:12){
  orig_forecast <- c(orig_forecast, last_origvalues[i]*(100+pred_yoygrowth[i])/100)
}
orig_forecast
```
<!-- INTERPRETATION OF ORIGINAL TIME SERIES FORECAST -->

\textit{Bonus Question:}
```{r}
```{r}
rmse_ar <- function(data, lag, hold_period) {
  #Remove holdout period from the end of the sample
  data_train <- data[1:(length(data) - hold_period)]
  
  # Estimate the AR model
  ar_model <- ar.ols(data_train, order.max = lag, demean = TRUE, intercept = TRUE)
  
  # Forecast for the holdout period
  data_test <- data[(length(data) - hold_period + 1):length(data)]
  ar_forecasts <- predict(ar_model, n.ahead = hold_period)
  
  # Compute the RMSE
  rmse <- sqrt(mean((data_test - ar_forecasts$pred)^2))
  return(rmse)
}


#RMSE for 50 different lag orders and returning the minimal   
rmse <- list()
for (x in 1:50) {
  rmse[[x]] <- rmse_ar(na.omit(industrial_prod$yoy), x, 6)
}
which.min((rmse))

#RMSE for 50 different lag orders and returning the minimal   
for (x in 1:50) {
  rmse[[x]] <- rmse_ar(na.omit(industrial_prod$yoy), x, 12)
}
which.min((rmse))

#RMSE for 50 different lag orders and returning the minimal   
rmse <- list()
for (x in 1:50) {
  rmse[[x]] <- rmse_ar(na.omit(industrial_prod$log), x, 6)
}
which.min((rmse))

#RMSE for 50 different lag orders and returning the minimal   
for (x in 1:50) {
  rmse[[x]] <- rmse_ar(na.omit(industrial_prod$log), x, 12)
}
which.min((rmse))
```
We run the function for the two time series and compare the RMSE for AR models up to order 50. For a holdout period of 6 months we find that the year on year growth rates are best predicted with an AR(16) model. For a holdout period of 12 months, an AR(1) model produces the lowest RMSE. 

For the log(industrial production) the lowest RMSE is produced by an AR(1) model for a 6 month holdout period. Over 12 months an AR(11) model serves as the best predictor. 

Remarkably, based on the forecast performance, the optimal lag order is significantly lower than the lag order chosen by the AIC or BIC criterion. The AIC would have selected a model of order 25 (for the logged time series) and 26 (for the year on year growth rates).   
```

# Excercise 2 - Killian and Park (2009)

\textit{and 3.1-3.3. Load the provided data by Kilian and Park (2009), which contains a measure of change in oil production, a measure of real economic activity, the real price of oil, and changes in real US dividend growth from 1973M1 to 2016M12.}
```{r}
data <- read.table("data_kilian_park_2009.txt")
#("Global Oil Production Change","Global Real Activity", "Real Price of Oil", "US Stock Returns")
colnames(data) <- c("GOPC","GRA","RPO","USSR")
head(data)
```

\textit{Using the the packages vars in R (or an equivalent one in another language), estimate the VAR described in section 2.2 using the variables in the same order as specified by Kilian and Park (2009).}
```{r}
mod1 <- VAR(data, p=24, type="const")
```

Due to the enormity of the VAR consisting of 24 lags and 4 time series, we decided to exclude the output at this point of the assignment. The estimated coefficients are instead given in the appendix.

\textit{Using the estimated VAR, compute impulse response functions (take a look at the irf() function in vars, it uses the same identification scheme as Kilian \& Park (2009) propose (recursive ordering based on a Cholesky decomposition of the vcov-matrix of the errors) by default. Replicate Figure 1 and the lower panel in figure 3 of Kilian \& Park (2009).3 Interpret the results.}

## Figure 1
```{r}
# TO DO
```

## Figure 3
```{r}
# TO TO
```


\textit{Calculate forecast error variance decompositions for the included variables (take a look at the fevd() function in vars). Replicate Table 2 of Kilian and Park (2009). Interpret the results.}

```{r}
fevd_mod1 <- vars::fevd(mod1, n.ahead=150)
table2 <- round(fevd_mod1$USSR[c(1,2,3,12,150),]*100,2) # We decided to use 150 as a proxy for infinity
rownames(table2) <- c("h=1","h=2","h=3","h=12","h=Inf")
table2
```

<!-- INTERPRETATION -->

\textit{Note that the dataset provided misses US stock market returns (due to the licensing of the underlying time series). Look for alternative data on the US stock market, create a variable similar to the one used by Kilian \& Park (2009). Re-estimate the model and replicate Figure 1 again as well as the top panel of Figure 3 and Table 1.5 Interpret the results.}

In this exercise we decided to use the S\&P 500 returns as well as the CPI data from the FRED database to create monthly real stock returns.  
```{r}
fred <- read.csv("FRED_MD_data.csv")[,c("sasdate","S.P.500","CPIAUCSL")][-1,]
str(fred)

# Extract SP500 Growth and Inflation
ret <- ts_transform(fred$S.P.500)$mom
inf <- ts_transform(fred$CPIAUCSL)$mom

# Compute deflated stock returns
stockret <- ret - inf
head(stockret, n=10)

# Create time series
stockret_ts <- ts(stockret, frequency=12, start=c(1959,1))
head(stockret_ts)
plot(stockret_ts)
stockret_ts <- window(stockret_ts, start=c(1973,1), end=c(2006,12))
plot(stockret_ts)
```

Using this data, we replicate the VAR given above. Again, the estimated coefficients are given in the appendix.
```{r}

data$adj_stock_returns <- stockret_ts[-1]

df_2 <- data[,c("GOPC", "GRA", "RPO", "adj_stock_returns")]

var_rep <- VAR(df_2, p = 24, type = "const")
```

## Replicating figure 1 
```{r}
# Supply Shock
irf_supply_specific_shocks <- irf(var_rep, impulse = "GOPC", response = "RPO", boot = TRUE, cumulative = FALSE, n.ahead = 15)

# Inverting Signs
for(x in 1:length(irf_supply_specific_shocks$irf$GOPC)){
  irf_supply_specific_shocks$irf$GOPC[x,] <- irf_supply_specific_shocks$irf$GOPC[x,]*(-1)
  irf_supply_specific_shocks$Upper$GOPC[x,] <- irf_supply_specific_shocks$Upper$GOPC[x,]*(-1)
  irf_supply_specific_shocks$Lower$GOPC[x,] <- irf_supply_specific_shocks$Lower$GOPC[x,]*(-1)
}

# Aggregate-demand shock
irf_agg_demand_shocks <- irf(var_rep, impulse = "GRA", response = "RPO", boot = TRUE, cumulative = FALSE, n.ahead = 15)


# Oil specific-demand shock
irf_oi_specific_demand_shocks <- irf(var_rep, impulse = "RPO", response = "RPO", boot = TRUE, cumulative = FALSE, n.ahead = 15)


# Figure 1
par(mfrow = c(1, 3))
plot(irf_supply_specific_shocks)

plot(irf_agg_demand_shocks)

plot(irf_oi_specific_demand_shocks)
```

<!-- INTERPRETATION -->

## Replicating the Top Panel of Figure 3
```{r}
# Supply shock
irf_supply_shock_stock <- irf(var_rep, impulse = "GOPC", response = "adj_stock_returns", boot = TRUE, cumulative = TRUE, n.ahead = 15)

# Inverting signs
for(x in 1:length(irf_supply_shock_stock$irf$GOPC)){
  irf_supply_shock_stock$irf$GOPC[x,] <- irf_supply_shock_stock$irf$GOPC[x,]*(-1)
  irf_supply_shock_stock$Upper$GOPC[x,] <- irf_supply_shock_stock$Upper$GOPC[x,]*(-1)
  irf_supply_shock_stock$Lower$GOPC[x,] <- irf_supply_shock_stock$Lower$GOPC[x,]*(-1)
}

# Aggregate-demand shock
irf_agg_demand_shock_stock <- irf(var_rep, impulse = "GRA", response = "adj_stock_returns", boot = TRUE, cumulative = TRUE, n.ahead = 15)

# Oil specific-demand shock
irf_oi_specific_demand_shock <- irf(var_rep, impulse = "RPO", response = "adj_stock_returns", boot = TRUE, cumulative = TRUE, n.ahead = 15)


# Figure 3
par(mfrow = c(1, 3))
plot(irf_supply_shock_stock)

plot(irf_agg_demand_shock_stock)

plot(irf_oi_specific_demand_shock)
```

## Replicating Table 1
Similar to before, we replicate table 1 using our data on S\&P500 returns.
```{r}
fevd_stock <- fevd(var_rep, n.ahead = 150)
fevd_stock <- round(fevd_stock$adj_stock_returns[c(1,2,3,12,150),]*100,2) # We decided to use 150 as a proxy for infinity
colnames(fevd_stock) <- c("GOPC","GRA","RPO","SP500 Returns")
rownames(fevd_stock) <- c("h=1","h=2","h=3","h=12","h=Inf")
fevd_stock
```

<!-- INTERPRETATION -->

\pagebreak
# Appendix

Here are some additional outputs which are way too long for the main document.

```{r}
# Summary of model 1
summary(mod1)

# Summary of model 2 using the SP500 stock returns
summary(var_rep)
```

