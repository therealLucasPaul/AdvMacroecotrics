---
title: "4423 Advanced Macroeconometrics 1 - Assignment 1"
author: "Unterweger L., Pirich G., Tijani S."
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

# Setup

Importing necessary packages

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(vars)
library(ggplot2)
library(stats)
library(urca)
library(forecast)
library(tidyverse)
library(quantmod)
library(lubridate)
library(gridExtra)
library(stargazer)
```

# Excercise 1: FRED-MD

\textit{Download the current version of the FRED-MD database and load it into R (or another statistical software of your choice). Note that the second line in the CSV-file denotes the suggested transformation, you have to remove it.}

```{r}
fredmd <- read.csv("FRED_MD_data.csv")[-1,]
head(fredmd[,1:6])
```

\textit{Create a function that takes a vector containing observations of a time series as input and returns a dataframe with the following transformed series in its columns as output:
\begin{itemize}
\item the original time series in its raw form.
\item the log-transformed time series.
\item month-on-month growth rates in percent.
\item year-on-year growth rates in percent.
\item the first lag of the year-on-year growth rates of the time series.
\end{itemize}}

```{r}
ts_transform <- function(x) {
  output <- data.frame(matrix(NA,    # Create empty data frame
                                 nrow = NROW(x),
                                 ncol = 0))
  output$raw <- x
  output$log <- log(x)
  output$mom <- ((x-lag(x))/lag(x))*100
  output$yoy <- ((x-lag(x, 12))/lag(x, 12))*100
  output$yoy_1stlag <- lag((x-lag(x, 12))/lag(x, 12))*100
  return(output)
}
```

\textit{Use the created function to create a dataframe with the various transformation for US industrial production (mnemonic INDPRO), plot the logged time series and the yearly changes produced by the function. Briefly describe the properties of the time series.}

```{r}
industrial_prod <- cbind(date=as.Date(fredmd$sasdate, "%m/%d/%Y"), ts_transform(fredmd$INDPRO))

p1 <- ggplot(na.omit(industrial_prod), aes(x=date,y=log))+
  geom_line( color="#69b3a2", alpha=0.9, linetype=1) +
  ylab("Logged Industrial Production (INDPRO)")

p2 <- ggplot(na.omit(industrial_prod), aes(x=date,y=yoy))+
  geom_line( color="#69b3a2", alpha=0.9, linetype=1) +
  ylab("YoY Change of Industrial Production")

grid.arrange(p1, p2, ncol=2, nrow = 1)
```

<!--ADD INTERPRETATION -->

\textit{Using suitable functions from the stats and urca package, assess the properties of both logged industrial production and its yearly growth rate. Plot the autocorrelation function and perform Dickey-Fuller tests to test for a unit root (note the different specifications, i.e. including a drift or a trend), interpret the results.}
```{r}
log_INDPRO <- ts(industrial_prod$log, frequency = 12, start = c(1959,1,1))
yoy_INDPRO <- ts(industrial_prod$yoy, frequency = 12, start = c(1959,1,1))

par(mfrow=c(1,2))
Acf(log_INDPRO)
Acf(yoy_INDPRO)
```


```{r}
summary(ur.df(na.omit(industrial_prod$yoy), lags = 0, type="none")) # Process is stationary
summary(ur.df(na.omit(industrial_prod$log), lags = 0, type="none")) # Cannot reject H0
summary(ur.df(na.omit(industrial_prod$log), lags = 0, type="drift"))
summary(ur.df(na.omit(industrial_prod$log), lags = 0, type="trend"))
```

<!-- INTERPRETATION -->

\textit{Estimate a suitable AR model (e.g. using the ar.ols() function) for the stationary time series (as determined in the previous point).1 How is the lag order determined by default? Use the estimated model to produceforecasts for the next year and plot them. Interpret their behaviour (i.e. are they converging towards a certain value? What could that be?). Use the produced forecasts to also forecast the change in the original time series.}

```{r}
mod_log <- ar.ols(industrial_prod$log, na.action = na.omit, 
                demean = TRUE, intercept = TRUE)
summary(mod_log)

mod_yoy <- ar.ols(industrial_prod$yoy, na.action = na.omit,
                demean = FALSE, intercept = FALSE)
summary(mod_yoy)
```
By default the lag order is determined by the AIC information criterion. For the log of INDPRO a lag order of 25 is estimated. The model for the year on year changes is estimated with lag order 26.

```{r}
predict_mod_log <- predict(mod_log, na.omit(industrial_prod$log), n.ahead = 12)

ts_log <- ts(industrial_prod$log, start=c(1959, 1), end=c(2023,1), frequency=12)
ts_log_pred <- ts(predict_mod_log$pred, start = c(2023, 1), end=c(2024,1), frequency=12)

plot.ts(ts_log,
        xlim = c(2000, 2024),
        ylim = c(4,4.8),
        xlab = "Time",
        ylab = "log(INDPRO)",
        main = "Forecast for log(INDPRO)", 
        col = "steelblue") #plotting th predicted values) #plotting th predicted values
points(ts_log_pred, type = "l", col = "darkred")
```


```{r}
predict_mod_log <- predict(mod_log, na.omit(industrial_prod$log), n.ahead = 480)

ts_log <- ts(industrial_prod$log, start=c(1959, 1), end=c(2023,1), frequency=12)
ts_log_pred <- ts(predict_mod_log$pred, start = c(2023, 1), end=c(2062,1), frequency=12)

plot.ts(ts_log,
        xlim = c(2000, 2062),
        ylim = c(4,4.8),
        xlab = "Time",
        ylab = "log(INDPRO)",
        main = "Forecast for log(INDPRO)", 
        col = "steelblue") #plotting th predicted values) #plotting th predicted values
points(ts_log_pred, type = "l", col = "darkred")
```

```{r}
predict_mod_yoy <- predict(mod_yoy, na.omit(industrial_prod$yoy), n.ahead = 12)

ts_yoy <- ts(industrial_prod$yoy, start=c(1959, 1), end=c(2023,1), frequency=12)
ts_yoy_pred <- ts(predict_mod_yoy$pred, start = c(2023, 2), end=c(2024,1), frequency=12)

plot.ts(ts_yoy,
        xlim = c(2000, 2024),
        xlab = "Time",
        ylab = "yoy(INDPRO)",
        main = "Forecast for yoy(INDPRO)", 
        col = "steelblue") #plotting th predicted values) #plotting th predicted values
points(ts_yoy_pred, type = "l", col = "darkred")
```

```{r}
predict_mod_yoy <- predict(mod_yoy, na.omit(industrial_prod$yoy), n.ahead = 480)

ts_yoy <- ts(industrial_prod$yoy, start=c(1959, 1), end=c(2023,1), frequency=12)
ts_yoy_pred <- ts(predict_mod_yoy$pred, start = c(2023, 1), end=c(2062,1), frequency=12)

plot.ts(ts_yoy,
        xlim = c(2000, 2062),
        xlab = "Time",
        ylab = "yoy(INDPRO)",
        main = "Forecast for yoy(INDPRO)", 
        col = "steelblue") #plotting th predicted values) #plotting th predicted values
points(ts_yoy_pred, type = "l", col = "darkred")
```

```{r}
A <- tail(na.omit(industrial_prod$raw),12)
B <- predict_mod_yoy$pred
C <- vector()
for(i in 1:12){
  C <- c(C, A[i]*(100+B[i])/100)
}
C
```

\textit{Bonus Question:}
```{r}

```

# Excercise 2 - Killian and Park (2009)

\textit{and 3.1-3.3. Load the provided data by Kilian and Park (2009), which contains a measure of change in oil production, a measure of real economic activity, the real price of oil, and changes in real US dividend growth from 1973M1 to 2016M12.}
```{r}
data <- read.table("data_kilian_park_2009.txt")
#("Global Oil Production Change","Global Real Activity", "Real Price of Oil", "US Stock Returns")
colnames(data) <- c("GOPC","GRA","RPO","USSR")
head(data)
```

\textit{Using the the packages vars in R (or an equivalent one in another language), estimate the VAR described in section 2.2 using the variables in the same order as specified by Kilian and Park (2009).}
```{r}
mod1 <- VAR(data, p=24, type="const")
```

\textit{Using the estimated VAR, compute impulse response functions (take a look at the irf() function in vars, it uses the same identification scheme as Kilian \& Park (2009) propose (recursive ordering based on a Cholesky decomposition of the vcov-matrix of the errors) by default. Replicate Figure 1 and the lower panel in figure 3 of Kilian \& Park (2009).3 Interpret the results.}

## Figure 1
```{r}
# to do
```

## Figure 3
```{r}
# to do
```


\textit{Calculate forecast error variance decompositions for the included variables (take a look at the fevd() function in vars). Replicate Table 2 of Kilian and Park (2009). Interpret the results.}

```{r}
fevd_mod1 <- vars::fevd(mod1, n.ahead=150)
table2 <- round(fevd_mod1$USSR[c(1,2,3,12,150),]*100,2) # We decided to use 150 as a proxy for infinity
table2
```

\textit{}
```{r}
fred <- read.csv("FRED_MD_data.csv")[,c("sasdate","S.P.500","CPIAUCSL")][-1,]
str(fred)

# Extract SP500 Growth and Inflation
ret <- input_function(fred$S.P.500)$mom_growth
inf <- input_function(fred$CPIAUCSL)$mom_growth

# Compute deflated stock returns
stockret <- ret - inf
head(stockret)

# Create time series
stockret_ts <- ts(stockret, frequency=12, start=c(1959,1))
head(stockret_ts)
plot(stockret_ts)
stockret_ts <- window(stockret_ts, start=c(1973,1), end=c(2006,12))
plot(stockret_ts)
```

```{r}

data$adj_stock_returns <- stockret_ts[-1]

df_2 <- data[,c("GOPC", "GRA", "RPO", "adj_stock_returns")]

var_rep <- VAR(df_2, p = 24, type = "const")
```


## Replicating figure 1 
```{r}
#supply shock
irf_supply_specific_shocks <- irf(var_rep, impulse = "GOPC", response = "RPO", boot = TRUE, cumulative = FALSE, n.ahead = 15)

#inverting signs
for(x in 1:length(irf_supply_specific_shocks$irf$GOPC)){
  irf_supply_specific_shocks$irf$GOPC[x,] <- irf_supply_specific_shocks$irf$GOPC[x,]*(-1)
  irf_supply_specific_shocks$Upper$GOPC[x,] <- irf_supply_specific_shocks$Upper$GOPC[x,]*(-1)
  irf_supply_specific_shocks$Lower$GOPC[x,] <- irf_supply_specific_shocks$Lower$GOPC[x,]*(-1)
}

#aggregate-demand shock
irf_agg_demand_shocks <- irf(var_rep, impulse = "GRA", response = "RPO", boot = TRUE, cumulative = FALSE, n.ahead = 15)


#oil specific-demand shock
irf_oi_specific_demand_shocks <- irf(var_rep, impulse = "RPO", response = "RPO", boot = TRUE, cumulative = FALSE, n.ahead = 15)


#figure 1
par(mfrow = c(1, 3))
plot(irf_supply_specific_shocks)

plot(irf_agg_demand_shocks)

plot(irf_oi_specific_demand_shocks)
```
## Replicating top panel of figure 3
```{r}
#supply shock
irf_supply_shock_stock <- irf(var_rep, impulse = "GOPC", response = "adj_stock_returns", boot = TRUE, cumulative = TRUE, n.ahead = 15)

#inverting signs
for(x in 1:length(irf_supply_shock_stock$irf$GOPC)){
  irf_supply_shock_stock$irf$GOPC[x,] <- irf_supply_shock_stock$irf$GOPC[x,]*(-1)
  irf_supply_shock_stock$Upper$GOPC[x,] <- irf_supply_shock_stock$Upper$GOPC[x,]*(-1)
  irf_supply_shock_stock$Lower$GOPC[x,] <- irf_supply_shock_stock$Lower$GOPC[x,]*(-1)
}

#aggregate-demand shock
irf_agg_demand_shock_stock <- irf(var_rep, impulse = "GRA", response = "adj_stock_returns", boot = TRUE, cumulative = TRUE, n.ahead = 15)

#oil specific-demand shock
irf_oi_specific_demand_shock <- irf(var_rep, impulse = "RPO", response = "adj_stock_returns", boot = TRUE, cumulative = TRUE, n.ahead = 15)


#figure 1
par(mfrow = c(1, 3))
plot(irf_supply_shock_stock)

plot(irf_agg_demand_shock_stock)

plot(irf_oi_specific_demand_shock)
```
## Replicating table 1 
```{r}
fevd_stock <- fevd(var_rep, n.ahead = 150)
fevd_stock_fevd <- round(fevd_stock$adj_stock_returns[c(1,2,3,12,150),]*100,2) # We decided to use 150 as a proxy for infinity
fevd_stock_fevd
```

<!-- INTERPRETATION -->



\pagebreak
# Appendix

Here are some additional outputs which are way too long for the main document.

```{r}
# Summary of model 1
summary(mod1)

# Summary of model 2 using the SP500 stock returns
summary(var_rep)
```

